//Thothie - this script does what sv_world is supposed to do
#scope server

{
	setvard MAGIC_HAND_SCRIPTS1 "magic_hand_acid_bolt;magic_hand_blizzard;magic_hand_div_glow;magic_hand_div_rejuvenate;magic_hand_fire_ball;magic_hand_fire_dart;magic_hand_fire_wall;magic_hand_frost_bolt;magic_hand_healing_circle;magic_hand_ice_blast;magic_hand_ice_shield;"
	setvard MAGIC_HAND_SCRIPTS2 "magic_hand_ice_shield_lesser;magic_hand_ice_wall;magic_hand_lightning_chain;magic_hand_lightning_storm;magic_hand_lightning_weak;magic_hand_poison;magic_hand_poison_cloud;magic_hand_summon_fangtooth;magic_hand_summon_guard;magic_hand_summon_rat;"
	setvard MAGIC_HAND_SCRIPTS3 "magic_hand_summon_undead;magic_hand_turn_undead;magic_hand_volcano;"

	const MAGIC_HAND_NAMES1 "Acidic Bolt;Blizzard;Glow;Rejuvenate;Fire Ball;Fire Dart;Fire Wall;Frost Bolt;Healing Circle;Ice Blast;Ice Shield;"
	const MAGIC_HAND_NAMES2 "Lesser Ice Shield;Ice Wall;Chain Lighting;Lightning Storm;Erratic Lightning;Poison Dart;Poison Cloud;Summon Fangtooth;Summon Guardian;Summon Rat"
	const MAGIC_HAND_NAMES3 "Summon Undead;Rebuke Undead;Volcano"

	const CONST_SPAWNS_PER_SET 8

	//const SND_COUNT_DOWN "vox/ten.wav;vox/nine.wav;vox/eight.wav;vox/seven.wav;vox/six.wav;vox/five.wav;vox/four.wav;vox/three.wav;vox/two.wav;vox/one.wav;vox/zero.wav;"

	setvard N_MALDORAS 0
	setvard MALDORA_LIST ''
	setvard DEMON_RAGE_USERS ''
	setvard DEMON_RAGE_USES ''
	setvard N_TELFL_DEAD 0

	const LIGHTSYS_N_LIGHTS 16
	array.create ARRAY_LIGHT_OWNERLIST
	array.create ARRAY_LIGHT_COLOR
	array.create ARRAY_LIGHT_RAD
	calleventloop LIGHTSYS_N_LIGHTS init_lights
}

{ init_lights
	array.add ARRAY_LIGHT_OWNERLIST game.script.iteration
	array.add ARRAY_LIGHT_COLOR -1
	array.add ARRAY_LIGHT_RAD -1
}

#include [casual] test_scripts/game_master
#include [casual] $currentmap_game_master

//Game master modules
#include game_master/map_transitions
#include game_master/vote_generic

{ game_spawn
	name The Game Master
	hp 1
	invisible 1
	invincible 1
	blind 1
	race hated
	width 32
	height 32
	gravity 0 //JUN2010_15

	saytextrange 64000 //we're at @-20000 so...

	if game.serverside

	dbg ***************** Game_Master - Spawned

	//old damage point system, no longer in use
	//array.create ARRAY_PLAYER_IDS
	//array.create ARRAY_PLAYER_SCORES
	//array.create ARRAY_PLAYER_ENTS

	servercmd "echo Game Master Spawned"

	setvard PLAYING_DEAD 1
	setvarg GAME_MASTER $get(ent_me,id)

	add G_NGAME_MASTERS 1

	if ( G_NGAME_MASTERS > 1 ) errormessage Multiple Game Masters! $get(ent_creationowner,name)

	name_unique game_master

	//dbg Game Master Spawned id GAME_MASTER

	//setup spawn time by system clock

	setvard TRIGGER_COUNT 0

	setvard SPAWN_TIME game.time.since.minutes

	if ( game.cvar.ms_chatlog )
	{
		chatlog " "
		chatlog ================================================================
		chatlog Server Init at: [ $timestamp() ] on $lcase(game.map.name)
		chatlog ================================================================
	}
	
	setvard DEV_PLAYER ''

	if ( game.central )
	{
		if game.cvar.ms_dev_mode
		errormessage "ms_dev_mode not allowed on [FN]."
	}

	callevent set_time 12 1 //ded servers have picked up a bug where time does not syc, causing "strobe" effect - hoping having the GM set it on spawn will fix

	//callevent set_chatlog_file
	callevent 0.1 setup_gm
	callevent 1.0 gm_setup_weather
	callevent 60.0 time_sync_check
}

{ [server] time_sync_check

	//scramble the global treasure lists ever few minutes to make them more "random"
	add GM_SCRAMBLE_COUNT 1
	if ( GM_SCRAMBLE_COUNT > $rand(2,5) )
	{
		setvard GM_SCRAMBLE_COUNT 0
		callevent gm_scramble_treasure
	}

	callevent 60.0 time_sync_check
	add G_MAP_UPTIME 1 //game master minute ticks (global initiated at map start)

	local CUR_TIC_TIME G_MAP_UPTIME
	add CUR_TIC_TIME SPAWN_TIME

	//local PRE_SUB CUR_TIC_TIME //debug
	subtract CUR_TIC_TIME game.time.since.minutes

	//infomsg all "TIME_INFO" Tic PRE_SUB vs Sys game.time.since.minutes ( diff CUR_TIC_TIME )
}

{ [server] send_damage //same params as do damage
	
	dodamage PARAM1 PARAM2 PARAM3 PARAM4 PARAM5 PARAM6 PARAM7
}

//Spawn gold bag post-mortem - 
{ [server] gold_spew //PARAM1=gold_per_bag PARAM2=bags_player PARAM3=dist_from_mon PARAM4=min#bags PARAM5 max#bags

	setvard GOLD_AMT PARAM1
	setvard BAGS_PER_PLAYER PARAM2
	setvard F_DIST PARAM3
	local MIN_BAGS PARAM4
	local MAX_BAGS PARAM5

	setvard GOLD_POS PARAM6

	if ( MIN_BAGS equals 'PARAM4' ) local MIN_BAGS 1
	if ( MAX_BAGS equals 'PARAM5' ) local MAX_BAGS 99
	if ( F_DIST equals 'PARAM3' ) setvard F_DIST 100

	//incvar [ loc (878.41,3579.85,-395.97) ] Gld 50 BgsPP 2 dst 100 minbags 1 mxbags 30

	setvard NUM_BAGS game.playersnb

	multiply NUM_BAGS BAGS_PER_PLAYER

	if ( NUM_BAGS < MIN_BAGS ) setvard NUM_BAGS MIN_BAGS
	if ( NUM_BAGS > MAX_BAGS ) setvard NUM_BAGS MAX_BAGS

	setvard ROT_STEP_SIZE 359
	divide ROT_STEP_SIZE NUM_BAGS

	setvard ROT_STEP 0
	
	setvard BAG_COUNT 0

	dbg gm_gold_spew ( PARAM1 PARAM2 PARAM3 PARAM4 PARAM5 ) Gld GOLD_AMT BgsPP BAGS_PER_PLAYER dst F_DIST minbags MIN_BAGS mxbags MAX_BAGS

	callevent 1.25 gold_spew_loop
}

{ [server] gold_spew_loop

	add BAG_COUNT 1

	local T_SPAWN GOLD_POS
	vectoradd T_SPAWN $relpos($vec(0,ROT_STEP,0),$vec(0,F_DIST,40))
	callevent make_bag T_SPAWN GOLD_AMT

	dbg bag # BAG_COUNT of NUM_BAGS @ T_SPAWN amt GOLD_AMT

	add ROT_STEP ROT_STEP_SIZE

	if ( BAG_COUNT < NUM_BAGS ) callevent 0.5 gold_spew_loop
}

{ [server] make_bag
	local INC_TSPAWN PARAM1
	local INC_GOLDAMT PARAM2
	createnpc chests/bag_o_gold_base INC_TSPAWN INC_GOLDAMT
}

//================ Post Mortem NPC Creation Management - Generic - BEGIN
//- Spawning multiple monsters after death causes lag (such as the "splitting" the black slimes do)
//- This cuts down on this
//- These also allow creation of delayed effects post-mortem
//- For instance, thunder-shock event timed delay with large monster falling over
//- This handles up to 4 createnpc commands
//- Format is same as createnpc, prefixed with desired delay
//- eg: callexternal GAME_MASTER gm_createnpc 0.1 CHILD_SCRIPT $relpos(0,-20,0) CHILD_MOVE_DEST MY_KILLER
{ [server] gm_createnpc
	setvard CNPCA_PAR1 PARAM2
	setvard CNPCA_PAR2 PARAM3
	setvard CNPCA_PAR3 PARAM4
	setvard CNPCA_PAR4 PARAM5
	setvard CNPCA_PAR5 PARAM6
	setvard CNPCA_PAR6 PARAM7
	setvard CNPCA_PAR7 PARAM8
	setvard CNPCA_PAR8 PARAM9

	callevent PARAM1 gm_createnpc_delayed
}

{ [server] gm_createnpc_delayed

	//dbg createnpc1 CNPCA_PAR1 CNPCA_PAR2 CNPCA_PAR3 CNPCA_PAR4 CNPCA_PAR5 CNPCA_PAR6 CNPCA_PAR7 CNPCA_PAR8
	createnpc CNPCA_PAR1 CNPCA_PAR2 CNPCA_PAR3 CNPCA_PAR4 CNPCA_PAR5 CNPCA_PAR6 CNPCA_PAR7 CNPCA_PAR8
}

{ [server] gm_createnpc2
	setvard CNPCB_PAR1 PARAM2
	setvard CNPCB_PAR2 PARAM3
	setvard CNPCB_PAR3 PARAM4
	setvard CNPCB_PAR4 PARAM5
	setvard CNPCB_PAR5 PARAM6
	setvard CNPCB_PAR6 PARAM7
	setvard CNPCB_PAR7 PARAM8
	setvard CNPCB_PAR8 PARAM9

	callevent PARAM1 gm_createnpc_delayed2
}

{ [server] gm_createnpc_delayed2

	//dbg createnpc2 CNPCB_PAR1 CNPCB_PAR2 CNPCB_PAR3 CNPCB_PAR4 CNPCB_PAR5 CNPCB_PAR6 CNPCB_PAR7 CNPCB_PAR8
	createnpc CNPCB_PAR1 CNPCB_PAR2 CNPCB_PAR3 CNPCB_PAR4 CNPCB_PAR5 CNPCB_PAR6 CNPCB_PAR7 CNPCB_PAR8
}

{ [server] gm_createnpc3
	setvard CNPCC_PAR1 PARAM2
	setvard CNPCC_PAR2 PARAM3
	setvard CNPCC_PAR3 PARAM4
	setvard CNPCC_PAR4 PARAM5
	setvard CNPCC_PAR5 PARAM6
	setvard CNPCC_PAR6 PARAM7
	setvard CNPCC_PAR7 PARAM8
	setvard CNPCC_PAR8 PARAM9

	callevent PARAM1 gm_createnpc_delayed3
}

{ [server] gm_createnpc_delayed3

	//dbg createnpc3 CNPCC_PAR1 CNPCC_PAR2 CNPCC_PAR3 CNPCC_PAR4 CNPCC_PAR5 CNPCC_PAR6 CNPCC_PAR7 CNPCC_PAR8
	createnpc CNPCC_PAR1 CNPCC_PAR2 CNPCC_PAR3 CNPCC_PAR4 CNPCC_PAR5 CNPCC_PAR6 CNPCC_PAR7 CNPCC_PAR8
}

{ [server] gm_createnpc4
	setvard CNPCD_PAR1 PARAM2
	setvard CNPCD_PAR2 PARAM3
	setvard CNPCD_PAR3 PARAM4
	setvard CNPCD_PAR4 PARAM5
	setvard CNPCD_PAR5 PARAM6
	setvard CNPCD_PAR6 PARAM7
	setvard CNPCD_PAR7 PARAM8
	setvard CNPCD_PAR8 PARAM9

	callevent PARAM1 gm_createnpc_delayed4
}

{ [server] gm_createnpc_delayed4

	//dbg createnpc4 CNPCD_PAR1 CNPCD_PAR2 CNPCD_PAR3 CNPCD_PAR4 CNPCD_PAR5 CNPCD_PAR6 CNPCD_PAR7 CNPCD_PAR8
	createnpc CNPCD_PAR1 CNPCD_PAR2 CNPCD_PAR3 CNPCD_PAR4 CNPCD_PAR5 CNPCD_PAR6 CNPCD_PAR7 CNPCD_PAR8
}
//================ Post Mortem NPC Creation Management - Generic - END
{ [server] gm_fade //<target> [rendermode]

	dbg gm_fade PARAM1 PARAM2 PARAM3

	if ( PARAM2 startswith PARAM )
	{
		local REND_MODE 5
	}
	else
	{
		local REND_MODE PARAM2
	}

	//make a target fade away - good for fading dead bodies, since they can't fade themselves

	if ( $get(FD_LOOP_TARG,exists) ) setprop FD_LOOP_TARG renderamt 0 //in case already fading something, set the current target render to ziltch
	
	//SEP2009_9 - allow setting of fade start, to fade faster
	if ( PARAM3 startswith PARAM )
	{
		setvard FD_LOOP_AMT 255
	}
	else
	{
		setvard FD_LOOP_AMT PARAM3
	}

	setvard FD_LOOP_TARG PARAM1
	setprop FD_LOOP_TARG rendermode REND_MODE

	callevent gm_fade_loop
}

{ [server] gm_fade_loop
	subtract FD_LOOP_AMT 5
	if ( FD_LOOP_AMT >= 0 ) setprop FD_LOOP_TARG renderamt FD_LOOP_AMT
	if FD_LOOP_AMT > 0
	callevent 0.1 gm_fade_loop
}

{ gm_say
	infomsg all "The Game Master Says..." PARAM1
}

{ [server] gm_fade_in //<target> <rendermode>

	if ( $get(FD_LOOP_TARG,exists) ) setprop FD_LOOP_TARG renderamt 255 //in case already fading something, finish manifesting him
	
	setvard FD_LOOP_AMT 0
	setvard FD_LOOP_TARG PARAM1
	setprop FD_LOOP_TARG rendermode PARAM2
	callevent gm_fade_in_loop
}

{ [server] gm_fade_in_loop
	add FD_LOOP_AMT 5
	if ( FD_LOOP_AMT <= 255 )
	{
		setprop FD_LOOP_TARG renderamt FD_LOOP_AMT
		callevent 0.1 gm_fade_in_loop
	}
	if ( FD_LOOP_AMT >= 255 )
	{
		callexternal FD_LOOP_TARG fade_in_done
	}
}

{ gm_worm_gold
	setvard WORM_ID $get(PARAM1,id)
	setvard WORM_GOLD game.playersnb
	multiply WORM_GOLD 2
	setvard WORM_COUNT 0
	setvard WORM_ITEM PARAM2
	callevent 1.0 gm_worm_gold_loop
}

{ gm_worm_gold_loop
	if WORM_COUNT < WORM_GOLD
	add	WORM_COUNT 1
	createnpc WORM_ITEM $get(WORM_ID,origin)
	callevent 0.5 gm_worm_gold_loop
}

{ worldevent_time

	local TIME_HOUR PARAM1
	local TIME_STRING mstime_
	stradd TIME_STRING TIME_HOUR
	usetrigger TIME_STRING hour_counter

	callevent gm_setup_weather
}

{ gm_set_weather //<weather_type> <lock:0|1> - from mstrig_weather
	local OUT_PAR1 PARAM1 
	local OUT_PAR2 PARAM2
	callevent game_set_weather OUT_PAR1 OUT_PAR2
}

{ game_set_weather //<weather_type> <lock:0|1> - from mstrig_weather
	if ( PARAM2 == 1 )
	{
		setvarg G_WEATHER_LOCK PARAM1
	}
	else
	{
		setvarg G_WEATHER_LOCK 0
	}
	local OUT_WEATHER PARAM1
	callevent gm_start_weather OUT_WEATHER
}

{ gm_setup_weather
	if ( G_WEATHER_LOCK equals 'G_WEATHER_LOCK' ) setvarg G_WEATHER_LOCK 0

	if ( G_WEATHER_LOCK isnot 0 )
	{
		setvarg G_CURRENT_WEATHER G_WEATHER_LOCK
		dbg gm_setup_weather sending lock G_WEATHER_LOCK
		callexternal players ext_weather_change G_WEATHER_LOCK
	}

	if ( G_CHRISTMAS_MODE )
	{
		local L_MAP_NAME $lcase(game.map.name)
		if ( L_MAP_NAME equals edana ) local XMASS_WEATHER 1
		if ( L_MAP_NAME equals deralia ) local XMASS_WEATHER 1
		if ( L_MAP_NAME equals helena ) local XMASS_WEATHER 1
		if ( XMASS_WEATHER ) setvarg global.map.weather "snow;snow;snow"
	}

	if G_WEATHER_LOCK equals 0

	//don't change weather during TOD cycles
	if TIME_HOUR isnot 6
	if TIME_HOUR isnot 17
	if TIME_HOUR isnot 20

	local N_WEATHER_TYPES $get_token_amt(global.map.weather)
	subtract N_WEATHER_TYPES 1
	local RND_WEATHER $rand(0,N_WEATHER_TYPES)
	setvarg G_CURRENT_WEATHER $get_token(global.map.weather,RND_WEATHER)
	dbg worldevent_time G_CURRENT_WEATHER ( RND_WEATHER of global.map.weather [ $get_token(global.map.weather,RND_WEATHER) ] )
	callevent gm_start_weather G_CURRENT_WEATHER
}

{ gm_crit_npc_died //<NPC> <killedby>
	//Critical NPC died, remove it from the global string
	//- cant be done from NPC, as is death event (script can't loop while dead)
	setvard NPC_DIED PARAM1
	setvard BY_ID PARAM2
	local N_NPCS $get_token_amt(G_CRITICAL_NPCS)
	calleventloop N_NPCS remove_crit_npc
	callevent 0.1 crit_count_remaining
}

{ remove_crit_npc
	local CUR_NPC $get_token(G_CRITICAL_NPCS,game.script.iteration)
	if ( CUR_NPC equals NPC_DIED ) token.del G_CRITICAL_NPCS game.script.iteration
}

{ crit_count_remaining

	local N_NPCS $get_token_amt(G_CRITICAL_NPCS)
	local N_NPCS $int(N_NPCS)
	if ( N_NPCS >= 0 )
	{
		if ( N_NPCS > 1 ) stradd N_NPCS " Critical NPC's Remain!"
		if ( N_NPCS == 1 ) local N_NPCS "Only One Critical NPC Remains!"
		if ( N_NPCS == 0 ) local N_NPCS "All Critical NPC's slain!"
		local MSG_REASON " "
		if ( $get(BY_ID,isplayer) )
		{
			local MSG_REASON $get(NPC_DIED,name)
			stradd MSG_REASON " WAS SLAIN BY FRIELDY FIRE! ( "
			stradd MSG_REASON $get(BY_ID,name)
			stradd MSG_REASON " )!"
		}
		infomsg all N_NPCS MSG_REASON
	}
}

{ gm_find_highest

	local CUR_VOTE_IDX game.script.iteration
	local CUR_VOTE_COUNT $get_token(VOTE_TALLY,CUR_VOTE_IDX)
	if ( VOTE_WINNAR_COUNT < CUR_VOTE_COUNT )
	{
		setvard VOTE_WINNAR_IDX CUR_VOTE_IDX
		setvard VOTE_WINNAR_COUNT CUR_VOTE_COUNT
	}
}

{ gm_dodamage
	local TIME_DIFF game.time
	subtract TIME_DIFF LAST_GM_DAMAGE
	if ( TIME_DIFF > 0.1 )
	{
		if ( PARAM2 equals direct ) dodamage PARAM1 PARAM2 PARAM3 PARAM4 PARAM5 PARAM6 PARAM7
		if ( PARAM6 equals reflective ) dodamage PARAM1 PARAM2 PARAM3 PARAM4 PARAM5 PARAM6 PARAM7 PARAM8
		//GM cant 'punch' so all hit-scan type is not needed
	}
}

{ game_monsterspawn_removed
	dbg game_monsterspawn_removed PARAM1
	local SPAWN_ID PARAM1
	callexternal all ext_monsterspawn_removed SPAWN_ID
	//infomsg all "DEBUG ALERT" "MSAREA_MONSTERSPAWN REMOVED"
}

{ game_playerspeak //<player> <type> <text>
	if ( G_DEVELOPER_MODE )
	{
		consolemsg PARAM1 You said [ PARAM2 ] PARAM3
	}

	if game.cvar.ms_chatlog
	local WRITE_LOG $timestamp(>)
	stradd WRITE_LOG " ["
	stradd WRITE_LOG $get(PARAM1,steamid)
	stradd WRITE_LOG "] "
	stradd WRITE_LOG $get(PARAM1,name)
	stradd WRITE_LOG "("
	stradd WRITE_LOG PARAM2
	stradd WRITE_LOG "): "
	stradd WRITE_LOG PARAM3
	chatlog WRITE_LOG
}

{ player_left
	if ( game.cvar.ms_chatlog )
	{
		chatlog $timestamp(>) PLAYER_LEFT: $get(PARAM1,name) [ $get(PARAM1,steamid) ] [ PlayerCountNow: game.players [ game.playersnb active ] ]
	}
}

{ delay_changelevel //Uses var DEST_MAP to change level. Intended for delays
	changelevel DEST_MAP
}

{ gm_setname
	name PARAM1
}

//==================================== POTION OF FORGETFUNLESS - BEGIN

{ forget_spell //PARAM1=owner PARAM2=potion_ID

	setvard FORGET_SPELL 1
	gplayermessage PARAM1 Please select a spell you would like to erase from memory.
	infomsg PARAM1 "Potion of Forgetfulness" "Please select a spell you would like to erase from memory."
	setvard SPELL_ERASE 1
	setvard MENU_TARGET PARAM1
	setvard POTION_ID PARAM2
	
	name a|Potion of Forgetfulness
	callevent 0.1 send_menu
}

{ game_menu_getoptions

	if ( SPELL_ERASE )
	{
		setvard SPELL_CASTER PARAM1
		calleventloop 7 add_spell_callbacks
		setvard SPELL_ERASE 0
		local EXIT_SUB 1
	}
}

{ add_spell_callbacks

	local CUR_IDX game.script.iteration

	local SPELL_SCRIPT $get(SPELL_CASTER,spellname,CUR_IDX)
	//if ( G_DEVELOPER_MODE ) gplayermessage SPELL_CASTER Slot CUR_IDX is SPELL_SCRIPT

	local SPELL_IDX 0
	local CHECK_SET1 -1
	local CHECK_SET2 -1
	local CHECK_SET3 -1

	local CHECK_SET1 $get_find_token(MAGIC_HAND_SCRIPTS1,SPELL_SCRIPT)
	if ( CHECK_SET1 > -1 )
	{
		local L_SPELL_NAME $get_token(MAGIC_HAND_NAMES1,CHECK_SET1)
		if ( G_DEVELOPER_MODE ) local SPELL_IDX 1
	}

	local CHECK_SET2 $get_find_token(MAGIC_HAND_SCRIPTS2,SPELL_SCRIPT)
	if ( CHECK_SET2 > -1 )
	{
		if CHECK_SET1 == -1
		local L_SPELL_NAME $get_token(MAGIC_HAND_NAMES2,CHECK_SET2)
		if ( G_DEVELOPER_MODE ) local SPELL_IDX 2
	}

	local CHECK_SET3 $get_find_token(MAGIC_HAND_SCRIPTS3,SPELL_SCRIPT)
	if ( CHECK_SET3 > -1 )
	{
		if CHECK_SET1 == -1
		if CHECK_SET2 == -1
		local L_SPELL_NAME $get_token(MAGIC_HAND_NAMES3,CHECK_SET3)
		if ( G_DEVELOPER_MODE ) local SPELL_IDX 3
	}

	if ( L_SPELL_NAME equals 'L_SPELL_NAME' )
	{
		local L_SPELL_NAME SPELL_SCRIPT
		if ( G_DEVELOPER_MODE ) consolemsg SPELL_CASTER was not found, using L_SPELL_NAME
	}

	//local reg.mitem.title $item_exists(SPELL_CASTER,SPELL_SCRIPT,name) //phayle, hence screwy crap above

	if ( G_DEVELOPER_MODE ) consolemsg SPELL_CASTER SPELL_SCRIPT is L_SPELL_NAME ( CHECK_SET1 CHECK_SET2 CHECK_SET3 )
	
	local reg.mitem.title	L_SPELL_NAME
	local reg.mitem.type 	callback
	local reg.mitem.data 	CUR_IDX
	local reg.mitem.cb_failed erase_spell_no
	local reg.mitem.callback 	confirm_forget_spell
	if ( reg.mitem.title isnot 0 ) menuitem.register
}

{ confirm_forget_spell

	local SPELL_SCRIPT $get(PARAM1,spellname,PARAM2)

	local CHECK_SET1 -1
	local CHECK_SET2 -1
	local CHECK_SET3 -1

	//setvard SPELL_NAME $item_exists(PARAM1,SPELL_SCRIPT,name) //phayle, h4x follow:
	local CHECK_SET1 $get_find_token(MAGIC_HAND_SCRIPTS1,SPELL_SCRIPT)
	if ( CHECK_SET1 > -1 )
	{
		local L_SPELL_NAME $get_token(MAGIC_HAND_NAMES1,CHECK_SET1)
	}

	local CHECK_SET2 $get_find_token(MAGIC_HAND_SCRIPTS2,SPELL_SCRIPT)
	if ( CHECK_SET2 > -1 )
	{
		if CHECK_SET1 == -1
		local L_SPELL_NAME $get_token(MAGIC_HAND_NAMES2,CHECK_SET2)
	}

	local CHECK_SET3 $get_find_token(MAGIC_HAND_SCRIPTS3,SPELL_SCRIPT)
	if ( CHECK_SET3 > -1 )
	{
		if CHECK_SET2 == -1
		local L_SPELL_NAME $get_token(MAGIC_HAND_NAMES3,CHECK_SET3)
	}

	if ( L_SPELL_NAME equals 'L_SPELL_NAME' ) local L_SPELL_NAME SPELL_SCRIPT

	setvard SPELL_NAME L_SPELL_NAME

	//infomsg MENU_TARGET "Potion of Forgetfulness" "Are you sure you want to forget L_SPELL_NAME ?"
	
	setvard SPELL_TO_FORGET_IDX PARAM2
	setvard SPELL_ERASE_CONFIRM 1
	setvard SPELL_ERASE 0
	setvard MENU_TARGET PARAM1
	callevent erase_spell MENU_TARGET
}

{ game_menu_cancel
	if FORGET_SPELL
	setvard SPELL_ERASE_CONFIRM 0
	setvard SPELL_ERASE 0
	setvard FORGET_SPELL 0
	effect screenfade MENU_TARGET 0.1 3 (10,10,10) 255 fadeout
}

{ send_menu
	menu.open MENU_TARGET
}

{ erase_spell
	wipespell PARAM1 SPELL_TO_FORGET_IDX
	local OUT_MSG "You "
	strconc OUT_MSG have forgotten the spell SPELL_NAME
	gplayermessage MENU_TARGET OUT_MSG
	infomsg MENU_TARGET "Potion of Forgetfulness" OUT_MSG
	setvard SPELL_ERASE_CONFIRM 0
	setvard SPELL_ERASE 0
	setvard FORGET_SPELL 0
	effect screenfade MENU_TARGET 0.1 3 (10,10,10) 255 fadeout
}
//==================================== POTION OF FORGETFUNLESS - END

{ gm_count_down
	if GM_COUNT_DOWN_TO >= 0
	if ( GM_COUNT_DOWN_TO <= 10 )
	{
		//precache these waves
		local WAVE_STEP 10
		subtract WAVE_STEP GM_COUNT_DOWN_TO
		//callexternal players ext_playsound $get_token(SND_COUNT_DOWN,WAVE_STEP)
		messageall green $int(GM_COUNT_DOWN_TO) GM_COUNT_MESSAGE
	}
	if ( GM_COUNT_DOWN_TO > 10 )
	{
		local DIV_TEN GM_COUNT_DOWN
		divide DIV_TEN 10
		if ( DIV_TEN == $int(GM_COUNT_DOWN) ) messageall green $int(GM_COUNT_DOWN_TO) GM_COUNT_MESSAGE
	}
	if ( GM_COUNT_DOWN_TO == 0 ) callevent GM_COUNT_DOWN_EVENT
	if GM_COUNT_DOWN_TO > 0
	subtract GM_COUNT_DOWN_TO 1
	callevent 1.0 gm_count_down
}

{ set_spawn_point

	local SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	local NEXT_SPAWN_SET CONST_SPAWNS_PER_SET

	if ( N_SPAWN_POINTS == 0 )
	{
		setvard SPAWN_POINTS1 ''
		setvard SPAWN_POINTS2 ''
		setvard SPAWN_POINTS3 ''
		setvard SPAWN_POINTS4 ''
		setvard SPAWN_POINTS5 ''
		setvard SPAWN_POINTS6 ''
		setvard SPAWN_POINTS7 ''
		setvard SPAWN_POINTS8 ''
		setvard SPAWN_POINTS9 ''
	}

	chatlog DEV: Adding spawn point # N_SPAWN_POINTS @ PARAM1

	//SPAWNS_PER_SET 8
	//NEXT_SPAWN_SET 8
	if ( N_SPAWN_POINTS <= SPAWNS_PER_SET  )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS1 PARAM1
	}

	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	//SPAWNS_PER_SET 8
	//NEXT_SPAWN_SET 16
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS2 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS3 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS4 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS5 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS6 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS7 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS8 PARAM1
	}

	add SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	add NEXT_SPAWN_SET CONST_SPAWNS_PER_SET
	if ( N_SPAWN_POINTS > SPAWNS_PER_SET )
	{
		if N_SPAWN_POINTS <= NEXT_SPAWN_SET
		token.add SPAWN_POINTS9 PARAM1
	}

	add N_SPAWN_POINTS 1
}

{ find_spawn_point //PARAM1 = target

	if N_SPAWN_POINTS > 0

	local MINUS_ONE N_SPAWN_POINTS
	subtract MINUS_ONE 1
	local RND_POINT $rand(0,MINUS_ONE)
	local O_SPAWN_POINT RND_POINT
	local RND_POINT_SET_IDX RND_POINT
	if ( RND_POINT > CONST_SPAWNS_PER_SET )
	{
																//RND_POINT 10 RND_POINT_SET_IDX 10
		divide RND_POINT_SET_IDX CONST_SPAWNS_PER_SET			//RND_POINT 10 RND_POINT_SET_IDX 1.xx
		local RND_POINT_SET_IDX $int(RND_POINT_SET_IDX)			//RND_POINT 10 RND_POINT_SET_IDX 1
		local MULTI_IDX RND_POINT_SET_IDX						//MULTI 1
		multiply MULTI_IDX CONST_SPAWNS_PER_SET					//MULTI 8
		subtract RND_POINT MULTI_IDX							//RND_POINT 2
		subtract RND_POINT 1									//RND_POINT 1
	}
	else
	{
		local RND_POINT_SET_IDX 0
	}

	local SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	if ( RND_POINT_SET_IDX == 0 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS1,RND_POINT)
	if ( RND_POINT_SET_IDX == 1 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS2,RND_POINT)
	if ( RND_POINT_SET_IDX == 2 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS3,RND_POINT)
	if ( RND_POINT_SET_IDX == 3 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS4,RND_POINT)
	if ( RND_POINT_SET_IDX == 4 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS5,RND_POINT)
	if ( RND_POINT_SET_IDX == 5 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS6,RND_POINT)
	if ( RND_POINT_SET_IDX == 6 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS7,RND_POINT)
	if ( RND_POINT_SET_IDX == 7 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS8,RND_POINT)
	if ( RND_POINT_SET_IDX == 8 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS9,RND_POINT)

	if ( G_DEVELOPER_MODE ) messageall green find_spawn_point: GM_SPAWN_POINT ( pt# O_SPAWN_POINT - idx# RND_POINT of N_SPAWN_POINTS set RND_POINT_SET_IDX )


	callexternal PARAM1 ext_send_tele_point GM_SPAWN_POINT
	//setorigin PARAM1 GM_SPAWN_POINT
}

{ dev_cat_points

	chatlog SPAWN_POINTS: N_SPAWN_POINTS
	chatlog SPAWN_POINTS1
	chatlog SPAWN_POINTS2
	chatlog SPAWN_POINTS3
	chatlog SPAWN_POINTS4

	setvard DEV_ID PARAM1
	messageall green dev_cat_points to $get(DEV_ID,name)
	calleventloop N_SPAWN_POINTS dev_cat_point_loop
}

{ dev_cat_point_loop

	local RND_POINT game.script.iteration
	local O_SPAWN_POINT RND_POINT
	local RND_POINT_SET_IDX RND_POINT
	if ( RND_POINT > CONST_SPAWNS_PER_SET )
	{
																//RND_POINT 8 RND_POINT_SET_IDX 
		divide RND_POINT_SET_IDX CONST_SPAWNS_PER_SET			//RND_POINT 10 RND_POINT_SET_IDX 1.xx
		local RND_POINT_SET_IDX $int(RND_POINT_SET_IDX)			//RND_POINT 10 RND_POINT_SET_IDX 1
		local MULTI_IDX RND_POINT_SET_IDX						//MULTI 1
		multiply MULTI_IDX CONST_SPAWNS_PER_SET					//MULTI 8
		subtract RND_POINT MULTI_IDX							//RND_POINT 2
		subtract RND_POINT 1									//RND_POINT 1
	}
	else
	{
		local RND_POINT_SET_IDX 0
	}

	if ( RND_POINT_SET_IDX == 0 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS1,RND_POINT)
	if ( RND_POINT_SET_IDX == 1 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS2,RND_POINT)
	if ( RND_POINT_SET_IDX == 2 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS3,RND_POINT)
	if ( RND_POINT_SET_IDX == 3 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS4,RND_POINT)
	if ( RND_POINT_SET_IDX == 4 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS5,RND_POINT)
	if ( RND_POINT_SET_IDX == 5 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS6,RND_POINT)
	if ( RND_POINT_SET_IDX == 6 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS7,RND_POINT)
	if ( RND_POINT_SET_IDX == 7 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS8,RND_POINT)
	if ( RND_POINT_SET_IDX == 8 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS9,RND_POINT)

	consolemsg DEV_ID pt# O_SPAWN_POINT is idx# RND_POINT of N_SPAWN_POINTS set RND_POINT_SET_IDX = GM_SPAWN_POINT
	messageall green pt# O_SPAWN_POINT is idx# RND_POINT of N_SPAWN_POINTS set RND_POINT_SET_IDX = GM_SPAWN_POINT
}

//{ dev_cat_points_set //PARAM1=dev PARAM2=set
//
//}

{ dev_test_spawn //PARAM1 = target PARAM2=point#

	if N_SPAWN_POINTS > 0

	local RND_POINT PARAM2
	local O_SPAWN_POINT RND_POINT
	local RND_POINT_SET_IDX RND_POINT
	if ( RND_POINT > CONST_SPAWNS_PER_SET )
	{
																//RND_POINT 10 RND_POINT_SET_IDX 10
		divide RND_POINT_SET_IDX CONST_SPAWNS_PER_SET			//RND_POINT 10 RND_POINT_SET_IDX 1.xx
		local RND_POINT_SET_IDX $int(RND_POINT_SET_IDX)			//RND_POINT 10 RND_POINT_SET_IDX 1
		local MULTI_IDX RND_POINT_SET_IDX						//MULTI 1
		multiply MULTI_IDX CONST_SPAWNS_PER_SET					//MULTI 8
		subtract RND_POINT MULTI_IDX							//RND_POINT 2
		subtract RND_POINT 1									//RND_POINT 1
	}
	else
	{
		local RND_POINT_SET_IDX 0
	}

	local SPAWNS_PER_SET CONST_SPAWNS_PER_SET
	if ( RND_POINT_SET_IDX == 0 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS1,RND_POINT)
	if ( RND_POINT_SET_IDX == 1 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS2,RND_POINT)
	if ( RND_POINT_SET_IDX == 2 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS3,RND_POINT)
	if ( RND_POINT_SET_IDX == 3 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS4,RND_POINT)
	if ( RND_POINT_SET_IDX == 4 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS5,RND_POINT)
	if ( RND_POINT_SET_IDX == 5 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS6,RND_POINT)
	if ( RND_POINT_SET_IDX == 6 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS7,RND_POINT)
	if ( RND_POINT_SET_IDX == 7 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS8,RND_POINT)
	if ( RND_POINT_SET_IDX == 8 ) setvard GM_SPAWN_POINT $get_token(SPAWN_POINTS9,RND_POINT)

	if ( G_DEVELOPER_MODE ) messageall green find_spawn_point: GM_SPAWN_POINT ( pt# O_SPAWN_POINT - idx# RND_POINT of N_SPAWN_POINTS set RND_POINT_SET_IDX )


	callexternal PARAM1 ext_send_tele_point GM_SPAWN_POINT
	//setorigin PARAM1 GM_SPAWN_POINT
}

{ gm_add_maldora_fragment
	add N_MALDORAS 1
	if ( GM_MALDORA_LIST equals 'GM_MALDORA_LIST' ) setvard GM_MALDORA_LIST ''
	token.add GM_MALDORA_LIST PARAM1	
}


{ item_demon_rage //<item_id> <user_id> <max_uses>
	local ITEM_ID PARAM1
	local USER_ID $get(PARAM2,steamid)
	local MAX_USES PARAM3

	local FIND_USER $get_find_token(DEMON_RAGE_USERS,USER_ID)
	if ( FIND_USER > -1 )
	{
		local CUR_USES $get_token(DEMON_RAGE_USES,FIND_USER)
		add CUR_USES 1
		token.set DEMON_RAGE_USES FIND_USER CUR_USES
	}
	else
	{
		token.add DEMON_RAGE_USERS USER_ID
		token.add DEMON_RAGE_USES 1
		local CUR_USES 1
	}

	local REM_USES MAX_USES
	subtract REM_USES CUR_USES

	dbg item_demon_rage PARAM1 PARAM2 PARAM3 ( charges REM_USES / MAX_USES )

	if ( CUR_USES > MAX_USES ) callexternal ITEM_ID demon_rage_maxed
	if ( CUR_USES <= MAX_USES ) callexternal ITEM_ID demon_rage REM_USES
}

{ gm_boost //same params as addvelocity
	addvelocity PARAM1 PARAM2 PARAM3
}

{ setup_gm

	setvarg G_MAP_ADDPARAMS 0

	if ( $len(game.map.addparams) > 1 )
	{
		setvarg G_MAP_ADDPARAMS game.map.addparams
		if ( $right(G_MAP_ADDPARAMS,1) isnot ';' ) stradd G_MAP_ADDPARAMS ;
	}

	dbg setup_gm gotaddparams G_MAP_ADDPARAMS

	//get spawn points
//	local SPAWN_POINTS
//	getspawnpoints SPAWN_POINTS
//	setvarg G_SPAWN_POINTS SPAWN_POINTS

	//map handlers
	if ( $lcase(game.map.name) startswith m2_quest ) setvard GM_HANDLE_ACTIVATES 1

	//get admins
	setvarg G_ADMIN_LIST ''
	setvarg G_ADMIN_AUTH ''
	setvard NO_ADMINS_FOUND 1
	callevent admin_load_list

	if game.time.month == 4
	if game.time.day == 1
	dbg Setup April Fools Mode (Delay)
	callevent $randf(10.0,600.0) gm_april_fools_mode
}


{ admin_load_list
	local IN_LINE $get_fileline(admins.txt)
	if IN_LINE isnot '[FILE_NOT_FOUND]'
	if IN_LINE isnot '[EOF]'
	local ADMIN_AUTH standard_
	local SKIP_LINE 0
	dbg reading,admins: IN_LINE
	if ( $left(IN_LINE,5) isnot 'STEAM' ) local SKIP_LINE 1
	if ( !SKIP_LINE )
	{
		if ( IN_LINE contains rcon ) stradd ADMIN_AUTH cvar_rcon_
		if ( IN_LINE contains cvar ) stradd ADMIN_AUTH cvar_
		if ( IN_LINE contains all ) local ADMIN_AUTH standard_rcon_cvar_
		local ADMIN_ID_START 0
		local PARSER " "
		local ADMIN_ID_END $search_string(IN_LINE,PARSER)
		if ( ADMIN_ID_END == -1 ) local ADMIN_ID_END $len(IN_LINE)
		local ADMIN_ID $left(IN_LINE,ADMIN_ID_END)
		//SEP2009 - This thing was writing to chatlog, regardless of ms_chatlog setting - fixed
		if ( game.cvar.ms_chatlog ) $timestamp(>) Adding_Admin: ADMIN_ID auth ADMIN_AUTH

		token.add G_ADMIN_LIST ADMIN_ID
		token.add G_ADMIN_AUTH ADMIN_AUTH
		setvard NO_ADMINS_FOUND 0
	}
	callevent 0.1 admin_load_list
}

{ set_wizard_center
	setvard WIZARD_CENTER PARAM1
}

{ gm_find_strongest_player

	dbg gm_find_strongest_player

	setvard STRONGEST_IDX 0
	setvard STRONGEST_STAT_LEVEL 0
	if ( STRONGEST_PLAYER_LIST equals 'STRONGEST_PLAYER_LIST' ) getplayersnb STRONGEST_PLAYER_LIST
	calleventloop $get_token_amt(STRONGEST_PLAYER_LIST) find_strongest_player_loop
	setvard THE_CHOSEN_ONE $get_token(STRONGEST_PLAYER_LIST,STRONGEST_IDX)
	setvard THE_CHOSEN_ONE_IDX STRONGEST_IDX
	token.del PLAYER_LIST STRONGEST_IDX
	//callevent inform_player //SEP2009 event not used (probably hold over from arti-chest)
}

{ gm_find_strongest_reset
	setvard STRONGEST_PLAYER_LIST 'STRONGEST_PLAYER_LIST'
	callevent gm_find_strongest_player
}

{ find_strongest_player_loop

	local CUR_IDX game.script.iteration
	local CUR_PLAYER $get_token(STRONGEST_PLAYER_LIST,CUR_IDX)
	local PLAYER_STAT $get(CUR_PLAYER,scriptvar,'PLR_TOTAL_DMG') //newfunc in player_main/game_master +1000 for heal/iceshield -1000 for death
	local PLAYER_SUB_STAT $get(CUR_PLAYER,scriptvar,'PLR_DMG') //fraction points
	multiply PLAYER_SUB_STAT 0.001 //note: this will drop fractions < 0.01
	add PLAYER_STAT PLAYER_SUB_STAT
	if ( PLAYER_STAT > STRONGEST_STAT_LEVEL )
	{
		setvard STRONGEST_STAT_LEVEL PLAYER_STAT
		setvard STRONGEST_IDX CUR_IDX
	}
}

{ set_shad_tele_point //<origin> <index> <trigger> (see mscave/shad_tele_base)

	if ( SHAD_TELEPOINTS equals 'SHAD_TELEPOINTS' ) setvard SHAD_TELEPOINTS "1;2;3;4;5;6;7"
	if ( SHAD_TRIGGERS equals 'SHAD_TRIGGERS' ) setvard SHAD_TRIGGERS "1;2;3;4;5;6;7"
	local POINT_INDEX PARAM2
	subtract POINT_INDEX 1
	dbg set_shad_tele_point POINT_INDEX PARAM1 PARAM3
	token.set SHAD_TELEPOINTS POINT_INDEX PARAM1
	token.set SHAD_TRIGGERS POINT_INDEX PARAM3
}

{ give_item_idx //<targetidx> <item_string> [params]

	callevent give_item $get_by_idx(PARAM1,id) PARAM2 PARAM3
}

{ give_item //<target> <item_string> [params...]
	//. eventgm give_item ME proj_arrow_jagged 15
	if ( PARAM3 startswith PARAM )
	{
		offer PARAM1 PARAM2
	}
	else
	{
		offer PARAM1 PARAM2 PARAM3
	}
}

{ gm_createitem //<delay> <item> <position> [reserve]

	if ( MAKING_ITEM ) infomsg all "ERROR" "Game failed to create an item due to script error."
	if !MAKING_ITEM
	local ITEM_TIME PARAM1
	setvard ITEM_NAME PARAM2
	setvard ITEM_POS PARAM3
	setvard GM_ITEM_RESERVE PARAM4
	setvard MAKING_ITEM 1
	callevent ITEM_TIME gm_createitem2
}

{ gm_createitem2
	setvard MAKING_ITEM 0
	createitem ITEM_NAME ITEM_POS
	if ( GM_ITEM_RESERVE ) callexternal ent_lastcreated bitem_reserve_for_strongest
}

//FEB2009_19
{ gm_hollow_one_died
	//slight delay to make sure all death events have time to process
	//and not unduely stress the server
	setvard HOLLOW_ONE_POS PARAM1
	clientevent update all const.localplayer.scriptID kh_dragon_death HOLLOW_ONE_POS
	callevent 1.0 gm_hollow_one_died2
}

{ gm_hollow_one_died2
	callevent gold_spew 500 2 72 4 8 HOLLOW_ONE_POS
}

{ gm_set_sorc_point //<origin> - external from other/sorc_telepoint

	if ( G_SORC_TELE_POINTS equals 'G_SORC_TELE_POINTS' ) setvarg G_SORC_TELE_POINTS 0

	add G_SORC_TELE_POINTS 1

	if ( SORC_TELE_SETS < 1 )
	{
		setvard SORC_TELE_SETS 1
		setvard SORC_CUR_TELE_SET 1
		setvard SORC_TELE_SET1 ''
	}

	if ( G_SORC_TELE_POINTS > 9 )
	{
		if SORC_TELE_SETS < 2
		setvard SORC_TELE_SETS 2 
		setvard SORC_CUR_TELE_SET 2
		setvard SORC_TELE_SET2 ''
	}

	if ( G_SORC_TELE_POINTS > 18 )
	{
		if SORC_TELE_SETS < 3
		setvard SORC_TELE_SETS 3
		setvard SORC_CUR_TELE_SET 3
		setvard SORC_TELE_SET3 ''
	}

	if ( SORC_CUR_TELE_SET == 1 ) token.add SORC_TELE_SET1 PARAM1
	if ( SORC_CUR_TELE_SET == 2 ) token.add SORC_TELE_SET2 PARAM1
	if ( SORC_CUR_TELE_SET == 3 ) token.add SORC_TELE_SET3 PARAM1
}

{ game_get_spawns
	setvarg G_SPAWN_POINTS PARAM1
}

//JUN2010_13 - delayed item give (to give potion time to delete before granting new ability item)
{ give_item_delayed //<target> <item_name> <delay> 
     setvard GM_ITEM_TARGET PARAM1 
     setvard GM_ITEM_NAME PARAM2 
     callevent PARAM3 give_item_delayed2 
} 
 
{ give_item_delayed2 
     offer GM_ITEM_TARGET GM_ITEM_NAME 
}

{ gm_add_del_que //<id_to_add> [min_delay]
	//items/monsters added to this que will be deleted (via fade out) within 15 secs
	//useful for monsters with non-conventional deaths (such as those using base_flyer_grav)
	local ID_TO_DEL PARAM1
	if ( $get_array(ARRAY_GM_DEL_QUE) contains '[ERROR_NO_ARRAY]' ) array.create ARRAY_GM_DEL_QUE
	array.add ARRAY_GM_DEL_QUE ID_TO_DEL

	if !GM_DEL_QUE_ACTIVE
	setvard GM_DEL_QUE_ACTIVE 1

	local FADE_DELAY PARAM2
	if ( PARAM2 startswith PARAM ) local FADE_DELAY 15.0

	callevent FADE_DELAY gm_del_que_loop
}

{ gm_del_que_loop
	dbg gm_del_que_loop $get_array_amt(ARRAY_GM_DEL_QUE)

	if ( $get_array_amt(ARRAY_GM_DEL_QUE) > 0 )
	{
		deleteent $get_array(ARRAY_GM_DEL_QUE,0) fade
		array.del ARRAY_GM_DEL_QUE 0
		callevent 2.0 gm_del_que_loop
	}
	else
	{
		setvard GM_DEL_QUE_ACTIVE 0
	}
}

{ gm_vanish_que //<ent> <delay_till_vanish>
	//items/monsters added to this que will be deleted (via fade out) within 15 secs
	//useful for monsters with non-conventional deaths (such as those using base_flyer_grav)
	local ID_TO_VANISH PARAM1
	if ( $get_array(ARRAY_GM_VANISH_QUE) contains '[ERROR_NO_ARRAY]' ) array.create ARRAY_GM_VANISH_QUE
	array.add ARRAY_GM_VANISH_QUE ID_TO_VANISH

	if !GM_VANISH_QUE_ACTIVE
	setvard GM_VANISH_QUE_ACTIVE 1

	local FADE_DELAY PARAM2

	callevent FADE_DELAY gm_vanish_que_loop
}

{ gm_vanish_que_loop
	dbg gm_vanish_que_loop $get_array_amt(ARRAY_GM_VANISH_QUE)

	if ( $get_array_amt(ARRAY_GM_VANISH_QUE) > 0 )
	{
		setprop $get_array(ARRAY_GM_VANISH_QUE,0) rendermode 5
		setprop $get_array(ARRAY_GM_VANISH_QUE,0) renderamt 0
		array.del ARRAY_GM_VANISH_QUE 0
		callevent 0.1 gm_vanish_que_loop
	}
	else
	{
		setvard GM_VANISH_QUE_ACTIVE 0
	}
}

{ gm_drop_item //<delay> <item_scriptname> <origin> [reserve_for_strongest:0|1]
	local ITEM_DELAY PARAM1
	setvard GM_ITEM_TO_GIVE PARAM2
	setvard GM_ITEM_ORIGIN PARAM3
	setvard GM_ITEM_RESERVE PARAM4
	callevent ITEM_DELAY gm_drop_item2
}

{ gm_drop_item2
	createitem GM_ITEM_TO_GIVE GM_ITEM_ORIGIN
	if ( GM_ITEM_RESERVE ) callexternal ent_lastcreated bitem_reserve_for_strongest
}

{ gm_start_weather //<type>

	if ( PARAM1 equals snow )
	{
		setvarg IS_SNOWING 1
	}
	else
	{
		setvarg IS_SNOWING 0
	}

	if ( PARAM1 contains rain )
	{
		setvarg IS_RAINING 1
	}
	else
	{
		setvarg IS_RAINING 0
	}

	local OUT_TRIG weatherchange_
	stradd OUT_TRIG G_CURRENT_WEATHER
	usetrigger OUT_TRIG //allow mappers to capture weather changes
	

	callexternal players ext_weather_change G_CURRENT_WEATHER
}

{ gm_test_trig

	local OUT_MSG $stradd(PARAM2,|,PARAM3,|,PARAM4,|,PARAM5)
	infomsg all $get(PARAM1,name) OUT_MSG
}

{ gm_trig_filter //<trigger_name> <tripper> <tokens>
	//totalhp>
	//totalhp<
	//avghp>
	//avghp<
	//race=
	//isally
	//isenemy
	//nplayers=*
	//nplayers>*
	//nplayers<*

	local TRIG_NAME PARAM1
	setvard GM_TRIG_TARGET PARAM2
	setvard GM_TRIG_TOKENS PARAM3


	local N_TOKENS $get_token_amt(GM_TRIG_TOKENS)
	setvard GM_TRIG_ACTIVATE 0
	setvard GM_RACE_ACTIVATE 0
	setvard GM_TRIG_HP_REQ 0
	setvard GM_TRIG_RACE_REQ 0
	calleventloop $get_token(GM_TRIG_TOKENS) gm_trig_filter_check

	local DO_TRIGGER 0
	if ( GM_RACE_ACTIVATE ) local DO_TRIGGER 1 //passed race test
	if ( GM_TRIG_HP_REQ ) local DO_TRIGGER 0 //but also has hpreq
	if ( GM_TRIG_ACTIVATE )
	{
		if ( GM_TRIG_RACE_REQ )
		{
			if GM_RACE_ACTIVATE //passed both hpreq and race test
			local DO_TRIGGER 1
		}
		else
		{
			local DO_TRIGGER 1 //passed hpreq, had no race test
		}
	}

	if DO_TRIGGER
	usetrigger TRIG_NAME	
}

{ gm_trig_filter_check
	local CUR_TOKEN $get_token(GM_TRIG_TOKENS,game.script.iteration)
	local LEN_TOKEN $len(CUR_TOKEN)
	if ( CUR_TOKEN startswith 'race=' )
	{
		setvard GM_TRIG_RACE_REQ 1
		local PROP_LEN LEN_TOKEN
		subtract PROP_LEN 5
		local PROP_STR $right(CUR_TOKEN,PROP_LEN)
		if ( $get(GM_RACE_TARGET,race) equals PROP_STR )
		{
			setvard GM_RACE_ACTIVATE 1
		}
		else
		{
			setvard GM_RACE_ACTIVATE 0
		}
	}
	if ( CUR_TOKEN startswith 'isally' )
	{
		setvard GM_TRIG_RACE_REQ 1
		if ( $get(GM_RACE_TARGET,race) equals human ) setvard GM_RACE_ACTIVATE 1
		if ( $get(GM_RACE_TARGET,race) equals elf ) setvard GM_RACE_ACTIVATE 1
		if ( $get(GM_RACE_TARGET,race) equals dwarf ) setvard GM_RACE_ACTIVATE 1
		if ( $get(GM_RACE_TARGET,race) equals hguard ) setvard GM_RACE_ACTIVATE 1
		if ( $get(GM_RACE_TARGET,isplayer) ) setvard GM_RACE_ACTIVATE 1
	}
	if  ( CUR_TOKEN startswith 'isenemy' )
	{
		setvard GM_TRIG_RACE_REQ 1
		setvard GM_RACE_ACTIVATE 1
		if ( $get(GM_RACE_TARGET,race) equals human ) setvard GM_RACE_ACTIVATE 0
		if ( $get(GM_RACE_TARGET,race) equals elf ) setvard GM_RACE_ACTIVATE 0
		if ( $get(GM_RACE_TARGET,race) equals dwarf ) setvard GM_RACE_ACTIVATE 0
		if ( $get(GM_RACE_TARGET,race) equals hguard ) setvard GM_RACE_ACTIVATE 0
		if ( $get(GM_RACE_TARGET,isplayer) ) setvard GM_RACE_ACTIVATE 0
	}

	if ( CUR_TOKEN startswith 'totalhp>' )
	{
		setvard GM_TRIG_HP_REQ 1
		local PROP_LEN LEN_TOKEN
		subtract PROP_LEN 8
		local PROP_STR $right(CUR_TOKEN,PROP_LEN)
		if ( game.players.totalhp >= PROP_STR )
		{
			setvard GM_TRIG_ACTIVATE 1
		}
		else
		{
			setvard GM_TRIG_ACTIVATE 0			
		}
	}
	if ( CUR_TOKEN startswith 'totalhp<' )
	{
		setvard GM_TRIG_HP_REQ 1
		local PROP_LEN LEN_TOKEN
		subtract PROP_LEN 8
		local PROP_STR $right(CUR_TOKEN,PROP_LEN)
		if ( game.players.totalhp < PROP_STR )
		{
			setvard GM_TRIG_ACTIVATE 1
		}
		else
		{
			setvard GM_TRIG_ACTIVATE 0			
		}
	}
	if ( CUR_TOKEN startswith 'avghp<' )
	{
		setvard GM_TRIG_HP_REQ 1
		local PROP_LEN LEN_TOKEN
		subtract PROP_LEN 6
		local PROP_STR $right(CUR_TOKEN,PROP_LEN)
		if ( game.players.avghp >= PROP_STR )
		{
			setvard GM_TRIG_ACTIVATE 1
		}
		else
		{
			setvard GM_TRIG_ACTIVATE 0			
		}
	}
	if ( CUR_TOKEN startswith 'avghp>' )
	{
		setvard GM_TRIG_HP_REQ 1
		local PROP_LEN LEN_TOKEN
		subtract PROP_LEN 6
		local PROP_STR $right(CUR_TOKEN,PROP_LEN)
		if ( game.players.avghp < PROP_STR )
		{
			setvard GM_TRIG_ACTIVATE 1
		}
		else
		{
			setvard GM_TRIG_ACTIVATE 0			
		}
	}
}

{ gm_april_fools_mode
	if ( !G_DEVELOPER_MODE )
	{
		if game.cvar.hostname contains RKS
		local GOOD_TO_GO 1
	}
	if ( G_DEVELOPER_MODE ) local GOOD_TO_GO 1
	if GOOD_TO_GO
	setvarg G_APRIL_FOOLS_MODE 1
	if ( G_DEVELOPER_MODE ) infomsg all "APRIL FOOLS MODE GO" "Checking april fool spawns"
}

{ gm_april_fools_spawn_add //<location>
	if !GM_APRIL_CHECKING
	dbg gm_april_fools_spawn_add PARAM1
	setvard GM_APRIL_SPAWN_POINT PARAM1
	setvard GM_APRIL_CHECKING 1
	callevent 10.0 gm_april_fools_check_point
}

{ gm_april_fools_check_point
	if GM_APRIL_CHECKING
	setvard GM_APRIL_CHECKING 0
	if ( game.players == 0 ) local EXIT_SUB 1
	if !EXIT_SUB
	getplayersnb APRIL_PLAYERS
	setvard GM_APRIL_INVALIDATED 0
	//make sure no players too close to desired spawn point
	//and last target is no longer on server
	calleventloop $get_token_amt(APRIL_PLAYERS) gm_april_fools_filter
	if !GM_APRIL_INVALIDATED
	setvarg G_APRIL_FOOLS_MODE 0
	callevent gm_spawn_newell
}

{ gm_spawn_newell
	dbg gm_spawn_newell
	createnpc monsters/gabe_newell GM_APRIL_SPAWN_POINT
}


{ gm_april_fools_filter
	local CUR_PLAYER $get_token(APRIL_PLAYERS,game.script.iteration)
	if ( CUR_PLAYER equals G_LAST_GABE_TARGET )
	{
		dbg gm_april_fools_filter - invalidated - last target still on server
		setvarg G_APRIL_FOOLS_MODE 0
		setvard GM_APRIL_INVALIDATED 1
	}

	local CUR_ORG $get(CUR_PLAYER,origin)
	if ( $dist(CUR_ORG,GM_APRIL_SPAWN_POINT) < 256 )
	{
		dbg gm_april_fools_filter - invalidated - too close, will check again
		setvard GM_APRIL_INVALIDATED 1 
	}
}

{ gm_recieve_client_info
	infomsg all "Returned" PARAM1
	consolemsg GM_PLAYER_REQ CLIENT_INFO_RETURNED: PARAM1
}

{ gm_newweather_string

	dbg got $get(PARAM1,name) PARAM2 PARAM3 PARAM4

	setvard GM_NEW_WEATHER PARAM2
	setvarg G_CURRENT_WEATHER PARAM2

	local NEW_WEATHER_STR PARAM1
	stradd NEW_WEATHER_STR ";"

	local ADD_PARAM 1
	if ( PARAM2 startswith PARAM ) local ADD_PARAM 0
	if ( ADD_PARAM )
	{
		local NEW_WEATHER_STR PARAM2
		stradd NEW_WEATHER_STR ";"
	}
	
	local ADD_PARAM 1
	if ( PARAM3 startswith PARAM ) local ADD_PARAM 0
	if ( ADD_PARAM )
	{
		local NEW_WEATHER_STR PARAM3
		stradd NEW_WEATHER_STR ";"
	}

	local ADD_PARAM 1
	if ( PARAM4 startswith PARAM ) local ADD_PARAM 0
	if ( ADD_PARAM )
	{
		local NEW_WEATHER_STR PARAM4
		stradd NEW_WEATHER_STR ";"
	}

	local ADD_PARAM 1
	if ( PARAM5 startswith PARAM ) local ADD_PARAM 0
	if ( ADD_PARAM )
	{
		local NEW_WEATHER_STR PARAM5
		stradd NEW_WEATHER_STR ";"
	}

	if ( G_CURRENT_WEATHER isnot PARAM2 )
	{
		callevent gm_start_weather G_CURRENT_WEATHER
	}
	
	setvarg global.map.weather NEW_WEATHER_STR
}

{ reserve_test //<targ_player>

	//precachefile PARAM2
	local SPAWN_POINT $get(PARAM1,origin)
	local MY_ANGLES $get(PARAM1,angles)
	local MY_YAW $vec.yaw(MY_ANGLES)
	vectoradd SPAWN_POINT $relpos($vec(0,MY_YAW,0),$vec(0,64,0))
	createitem smallarms_nh SPAWN_POINT
	dbg reserve_test $get(ent_lastcreated,name)
	callexternal ent_lastcreated item_banked
}

{ gm_keldorn_troll
	
	clientevent update PARAM1 const.localplayer.scriptID cl_playsound "voices/deralia/slinker2.wav"
	offer PARAM1 scroll2_trollcano
}

{ gm_sxbow_swap
	setvard GM_SXBOW_RECIEVE PARAM1
	callevent 1.0 gm_sxbow_swap2
}

{ gm_sxbow_swap2
	offer GM_SXBOW_RECIEVE bows_sxbow
}

{ gm_epilepsy_begin
	callexternal players ext_epilepsy_time_begin
}

{ gm_epilepsy_end
	callexternal players ext_epilepsy_time_end
}

{ player_joined //<id> - called from player_main->activate_stuff
	setvard GM_HAD_PLAYER 1
	callevent gm_lights_sync $get(PARAM1,index)
}

{ gm_lights_sync //<owner_id>
	//new player joined, send him all current player lights	
	dbg gm_lights_sync
	local L_N_LIGHTS $get_array_amt(ARRAY_LIGHT_OWNERLIST)
	setvard GM_LIGHT_PLAYER PARAM1
	if L_N_LIGHTS > 0
	calleventloop L_N_LIGHTS gm_lights_sync_loop
}

{ gm_lights_sync_loop
	local CUR_OWNER $get_array(ARRAY_LIGHT_OWNERLIST,game.script.iteration)
	local CUR_COLOR $get_array(ARRAY_LIGHT_COLOR,game.script.iteration)
	local CUR_RAD $get_array(ARRAY_LIGHT_RAD,game.script.iteration)
	dbg gm_lights_sync_loop sending CUR_OWNER CUR_COLOR CUR_RAD
	clientevent update GM_LIGHT_PLAYER const.localplayer.scriptID cl_light_update new CUR_OWNER CUR_COLOR CUR_RAD
}

{ gm_dumplights
	calleventloop LIGHTSYS_N_LIGHTS gm_dumplights_loop
}

{ gm_dumplights_loop
	local CUR_IDX game.script.iteration
	dbg $int(CUR_IDX) $get_array(ARRAY_LIGHT_OWNERLIST,CUR_IDX) $get_array(ARRAY_LIGHT_COLOR,CUR_IDX) $get_array(ARRAY_LIGHT_RAD,CUR_IDX) 
}

{ gm_light_update //<new|remove|update|clear> <owner_index> <color> <rad> [debug]

	local L_ACTION PARAM1
	local L_OWNER PARAM2
	local L_COLOR PARAM3
	local L_RAD PARAM4

	dbg gm_light_update L_ACTION L_OWNER L_COLOR L_RAD

	clientevent update all const.localplayer.scriptID cl_light_update L_ACTION L_OWNER L_COLOR L_RAD

	if ( L_ACTION equals new )
	{
		//update and new are really the same now, due to AUG2013 changes, so far as the gm tracker is concerned
		array.set ARRAY_LIGHT_COLOR L_OWNER L_COLOR
		array.set ARRAY_LIGHT_RAD L_OWNER L_RAD

		//check if light owner already exists, if so, update instead
//		local L_FIND_IDX $get_arrayfind(ARRAY_LIGHT_OWNERLIST,L_OWNER)
//		if ( L_FIND_IDX > -1 )
//		{
//			local L_ACTION update
//		}
//		else
//		{
//			array.set ARRAY_LIGHT_COLOR L_OWNER L_COLOR
//			array.set ARRAY_LIGHT_RAD L_OWNER L_RAD
//		}
	}

	if ( L_ACTION equals update )
	{
		//local L_LIGHT_IDX $get_arrayfind(ARRAY_LIGHT_OWNERLIST,L_OWNER)
		array.set ARRAY_LIGHT_COLOR L_OWNER L_COLOR
		array.set ARRAY_LIGHT_RAD L_OWNER L_RAD
	}

	if ( L_ACTION equals remove )
	{
		//local L_LIGHT_IDX $get_arrayfind(ARRAY_LIGHT_OWNERLIST,L_OWNER)
		array.set ARRAY_LIGHT_COLOR L_OWNER -1
		array.set ARRAY_LIGHT_RAD L_OWNER -1
	}
}

{ ext_activate_items //This is an m2_quest only function...
	if GM_HANDLE_ACTIVATES
	if ( $lcase(game.map.name) startswith m2_quest )
	{
		usetrigger global
		setvard GM_HANDLE_ACTIVATES 0
	}
}

{ gm_scramble_treasure
	token.scramble G_NOOB_ITEMS1
	token.scramble G_NOOB_ITEMS2
	token.scramble G_NOOB_ITEMS3
	token.scramble G_NOOB_ITEMS4
	token.scramble G_NOOB_ITEMS5
	token.scramble G_NOOB_ITEMS6
	token.scramble G_GOOD_ITEMS1
	token.scramble G_GOOD_ITEMS2
	token.scramble G_GOOD_ITEMS3
	token.scramble G_GREAT_ITEMS1
	token.scramble G_GREAT_ITEMS2
	token.scramble G_GREAT_ITEMS3
	token.scramble G_NOOB_ARROWS
	token.scramble G_GOOD_ARROWS
	token.scramble G_GREAT_ARROWS
	token.scramble G_EPIC_ARROWS

	setvard GM_N_EPICS $g_get_array_amt(G_ARRAY_EPIC)

	//initiate temp array to dump global treasure list into
	if ( $get_array_amt(ARRAY_TEMP) == -1 )
	{
		array.create ARRAY_TEMP
		calleventloop GM_N_EPICS gm_init_array_temp
	}

	//set random point to where to begin dump
	local L_N_EPICS GM_N_EPICS
	subtract L_N_EPICS 1
	setvard GM_TEMP_COUNT $rand(0,L_N_EPICS)

	//dump global epic array into temp
	calleventloop GM_N_EPICS gm_epic_to_temp_loop

	//and back again
	calleventloop GM_N_EPICS gm_temp_to_epic_loop
}

{ gm_init_array_temp
	array.add ARRAY_TEMP 0
}

{ gm_epic_to_temp_loop
	local CUR_EPIC game.script.iteration
	array.set ARRAY_TEMP GM_TEMP_COUNT $g_get_array(G_ARRAY_EPIC,CUR_EPIC)
	add GM_TEMP_COUNT 1
	if ( GM_TEMP_COUNT >= GM_N_EPICS ) setvard GM_TEMP_COUNT 0 //wrap around
}

{ gm_temp_to_epic_loop
	local CUR_EPIC game.script.iteration
	g_array.set G_ARRAY_EPIC CUR_EPIC $get_array(ARRAY_TEMP,CUR_EPIC)
}

//debugary
{ gm_dump_epics
	calleventloop $g_get_array_amt(G_ARRAY_EPIC) gm_dump_epics_loop
}

{ gm_dump_epics_loop
	local CUR_EPIC game.script.iteration
	dbg # CUR_EPIC $g_get_array(G_ARRAY_EPIC,CUR_EPIC)
}

{ gm_ms_text //<npc_name> <text> called by ms_text ent - but should work fine from anywhere
	dbg gm_ms_text PARAM1 PARAM2
	local L_NAME PARAM1
	local L_TEXT PARAM2
	name L_NAME
	saytext L_TEXT
}

{ gm_suspend_mob_spawns //0|1
	//for temporarily suspending monster spawning (deletes on spawn via base_monster_shared)
	setvard GM_DISABLE_SPAWNS PARAM1
}

{ gm_trigger_hpseq_count //<(ignored)> <trigger> activated by trigger relay rly_door_count on orc_for
	if ( GM_BTROLLS_DEAD equals 'GM_BTROLLS_DEAD' )
	{
		setvard GM_BTROLLS_DEAD 1
	}
	else
	{
		add GM_BTROLLS_DEAD 1
	}
	
	if GM_BTROLLS_DEAD >= GM_TOTAL_TRIGGERED
	local L_TRIGGER PARAM2
	usetrigger L_TRIGGER
}

{ gm_trigger_hpseq //<caller(ignored)> <trigger_prefix> <hpreqs...>
	//spawn_btrolls_;0;500;1000;1500;2000;3000
	setvard GM_TRIGGER_PREFIX PARAM2
	setvard GM_HP_TOKENS PARAM3
	local L_N_PARAMS game.event.params
	if ( L_N_PARAMS > 3 ) token.add GM_HP_TOKENS PARAM4
	if ( L_N_PARAMS > 4 ) token.add GM_HP_TOKENS PARAM5
	if ( L_N_PARAMS > 5 ) token.add GM_HP_TOKENS PARAM6
	if ( L_N_PARAMS > 6 ) token.add GM_HP_TOKENS PARAM7
	if ( L_N_PARAMS > 7 ) token.add GM_HP_TOKENS PARAM8
	if ( L_N_PARAMS > 8 ) token.add GM_HP_TOKENS PARAM9
	
	setvard GM_TOTAL_HP game.playersnb.totalhp
	setvard GM_TOTAL_TRIGGERED 0
	calleventloop $get_token_amt(GM_HP_TOKENS) gm_trigger_hpseq_loop
}

{ gm_trigger_hpseq_loop
	local CUR_HPREQ $get_token(GM_HP_TOKENS,game.script.iteration)
	if ( GM_TOTAL_HP >= CUR_HPREQ )
	{
		local L_TRIGGER GM_TRIGGER_PREFIX
		stradd L_TRIGGER CUR_HPREQ
		usetrigger L_TRIGGER
		add GM_TOTAL_TRIGGERED 1
	}
}

//{ game_triggered //<map trigger fired>
//
//}

//---Quest Items

{ ext_got_quest_item //<item_code> //Qitem found, add it to items found

	if ( $get_array_amt(ARRAY_QUEST_ITEMS) == -1 )
	{
		array.create ARRAY_QUEST_ITEMS
	}

	array.add ARRAY_QUEST_ITEMS PARAM1

	if ( $lcase(game.map.name) startswith 'rmine' ) //lame
	{
		if !PLR_FOUND_FIRST_STICK
		setvard PLR_FOUND_FIRST_STICK 1
		infomsg all "Stick of Dynamite" "Hrmmm... the fuse is broken... but maybe we can use this, somewhere..."
	}
}

//TODO: Make this event the only one that should need to be called.
// It should:
// Take PARAM1 as the QITEM CODE
// Take PARAM2 as the calling NPC
// Check if the item exists
// If it does, count all of them that exist
// Delete those entries
// Call back to the npc that number of times

{ ext_check_quest_item //<item_code> <caller_id> //Called from npc that needs a particular item. Find and removes qitem if found, then call back to the npc.

	setvard QITEM_NAME PARAM1
	setvard QITEM_CALLER PARAM2
	
	local L_FIND_ITEM $get_arrayfind(ARRAY_QUEST_ITEMS,QITEM_NAME)

	if ( L_FIND_ITEM equals '[ERROR_NO_ARRAY]' )
	{
		exitevent
	}

	if ( L_FIND_ITEM > -1 ) //If item was found
	{
		calleventloop $get_array_amt(ARRAY_QUEST_ITEMS) find_all_qitems //Finds each qitem, deletes the entry, then calls the NPC
	}
}

{ find_all_qitems

	local L_IDX game.script.iteration
	
	local L_FIND_ITEM $get_arrayfind(ARRAY_QUEST_ITEMS,QITEM_NAME)
	
	if ( L_FIND_ITEM > -1 )
	{
		array.del ARRAY_QUEST_ITEMS L_FIND_ITEM
		callexternal QITEM_CALLER ext_receive_quest_item QITEM_NAME
	}
	else
	{
		exitevent
	}
}

{ ext_dump_quest_items //Dumps all qitems to the console
	calleventloop $get_array_amt(ARRAY_QUEST_ITEMS) ext_dump_quest_items_loop
}

{ ext_dump_quest_items_loop
	dbg $get_array(ARRAY_QUEST_ITEMS,game.script.iteration)
}
